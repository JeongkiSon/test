'''
DFS (Depth-First SEarch) 깊이를 우선적으로 탐색, 들어갈 수 있을 때까지 진입함
깊이 우선 탐색, 그래프에서 깊은 부분을 우선적으로 탐색
DFS는 스택 자료구조(혹은 재귀함수)를 이옹한다


1) 탐색 시작 노드를 스택에 삽입하고 방문처리
2) 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면
그 노드를 스택에 넣고 방문 처리합니다. 방문하지 않은 인접노드가 없으면
스택에서 최상단 노드를 꺼낸다.
#)더 이상 2번의 과정을 수행할 수 없을 때까지 반복


'''


#dfs 구현
def dfs(graph, v, visited):
    visited[v] = True #현재 노드 방문처리
    print(v, end= ' ')
    #현재 노드와 연결된 노드로 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]: #방문 안됬으면 재귀적으로 방문 , 처음에는 i in graph[1] = [2, 3, 8이런 식으로]
            dfs(graph, i , visited)
'''
각 노드가 연결된 정보를 표현(2차원 리스트로 노드들이 어떻게 연결되어 있는지)
파이썬에서 그래프를 2차원 배열로 표현!!
인덱스 0번째에는 비워둠 노드 번호가 1번부터 시작하니까
2, 3, 8 이라는 거는 1번 노드에 2번 3번 8번이 연결되어 있다는 것
'''
graph =[
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

#각 노드가 방문된 정보를 표현(1차원 리스트)

visited = [False] * 9 #0번째 인덱스 안쓰니까 하나 더 크게 잡음

#정의된 DFS 함수 호출
dfs(graph, 1, visited)

''' 출력결과 탐색 순서
1 2 7 6 8 3 4 5  
1탐색후 2, 2 탐색후 7 그다음 6까지 최대한 깊게, 들어갈 수 있을 때까지 들어감
그다음 나와서 8찍고 그다음 3 4 5 깊이 순으로!
graph 에서 방문할 때 같이 연결되면 
작은 노드부터 방문하게끔 되어있는데 그걸 graph를 2차원 리스트로 구현할 때
아예 작은거 부터 오름차순으로 적어 놔서 그대로 구현됨 

'''


'''
BFS(Breadth-First Search) 너비 우선 탐색, 그래프에서 가까운 노드부터 우선적으로 탐색
큐 queue 자료구조 이용,

1) 탐색 시작 노드를 큐에 삽입하고 enqueue 방문처리
2) 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두
큐에 삽입하고 방문처리
3) 더 이상 2번의 과정을 수행할 수 없을 때까지 반복

DFS 는 방문하지 않은 노드들을 넣을 때 하나씩 넣었는데
BFS는 한번에 넣음 

최단 경로 문제 풀 때 사용가능

탐색순서
1 2 3 8 7 4 5 6
말 그대로 너비 우선, 거리 즉 기준 노드 기준 가장 가까운 거부터
1 다음 2 3 8 그다음 7 4 5, 그다음 6 임 7 4 5 는 1기준 같은 거리 에 있는 노드 이고
2에 7이 붙어 있어서 7이 먼저 출력된 것일 뿐

간선의 비용이 모두 동일 할 때 최단 거리 문제 해결 가능

BFS 구현
'''

from collections import deque # 큐 구현 위해 deque 라이브러리 사용

#BFS 구현

def bfs(graph, start, visited):
    queue = deque([start])
    visited[start] = True  #현재 노드 방문처리 
    
    while queue:  #큐가 빌 때까지 반복 즉 다 방문하고 dequeue 할 때까지
        v = queue.popleft() #원소 한개 dequeue
        print(v, end =' ')
        for i in graph[v]:  
            if not visited[i]:  #방문하지 않은 인접원소
                queue.append(i)  #를 큐에 삽입
                visited[i] = True
        

graph =[
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

visited = [False] * 9

print()
bfs(graph, 1, visited)


