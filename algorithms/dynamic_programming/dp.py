'''
 다이나임 긒로그래밍은 메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상시키는 방법
!!!! 답 재활용!!!
 !!!기억하며 풀기!!
 ***이미 게산된 결과(작은 문제)는 별도의 메모리 영역에 저장해 다시 계산하지 않도록 함
 
 dp의 구현은 일반적으로 두 가지 방식 (탑다운 하향식과 바텀업 상향식으로 구성됨)
 
 
 다이나믹 프로그래밍은 동적 계획법이라고도 부른다
 
 여기서 '동적'은 일반적인 프로그래밍 분야에서의 동적이랑 다름
 일반적인 프로그래밍 분야에서 dynamic (동적)은  '프로그램이 실행되는 도중에'의 뜻임
 
 자료구조에서 동적할당(dynamic allocation)은 프로그램이 실행되는 도중에
 실행에 필요한 메모리를 할당하는 기법을 의미함
 
 반면에 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어임
 
 
 
 
 다이나믹 프로그래밍은 문제가 다음의 조건을 만족해야함
 
 1.최적 부분 구조(optimal substructure) #
 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결 가능
 
 2 중복되는 부분 문제(overlapping subproblem) #부분문제가 중첩되서 등장한다
 동일한 작은 문제를 반복적으로 해결해야함
 
 
 피보나치 수열
 1 1 2 3 5 8 13....
 
 점화식: 인접한 항들 사이의 관계씩
 
an = an-1 + an-2 , a1 = 1, a 2 = 1

이러한 점화식은 재귀함수로 구현할 수 있음

n번째 피보나치 수를 f(n)이라 할 떄 4번째 피보나치 수 f(4)를 구하는 과정은
트리 구조로 표현가능
            f(4)
        f(3)    f(2)
      f(2)  f(1)   

재귀적으로 가능


'''

#reculsive way
def fibo(x):
    if x == 1 or x == 2:
        return x
    else:
        return fibo(x-1) + fibo(x-2)

print(fibo(20))   #매우 오래 걸림 


'''
단순 재귀 함수로 피보나치 수열을 구현하면 지수 시간 복잡도를 갖는다
왜냐면 an = an-1 + an-2라 f(6)부르면 f(5)랑 f(4)호출하게 되니까 두개씩 호출됨

f(6)이라 하면 f(2)가 여러 번 호출됨
f(2)는 이미 해결 했으니까 메모리에 저장해놓고 다음에 바로 쓸 수 있게 하면
시간을 아낄 수 있다

재귀로 구현하면 빅오 표기법 O(2^N)의 시간 복잡도임


dp 조건
1 큰 문제를 작은 문제로 나눌 수 있다 : 최적 부분 구조
2 동일한 작은 문제를 반복적으로 해결 : 중복되는 부분 문제

dp의 두가지 구현 법 중 탑다운
에서 Memoization(메모이제이션)은 한번 계산한 걸 메모리 공간에 메모하는 기법임

같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
값을 기록해 놓는다는 점에서 캐싱(cashing)이라고도 함
dp에서 배열 이름을 cashing , memo, table, dp, d 등으로 하기도 함

탑 다운 하향식, 바텀 업 상향식

top-down 은 큰 문제부터 해결!!!!! ->하기 위해 재귀로 새끼문제를 호출!!
재귀함수를 이용하고 큰 문제를 해결하기 위해
작은 걸 재귀적으로 호출하고 그 과정에서 한 번 계산 된 값을 기록하기 위해
memoization 을 함

bottom-up은 아래서부터 작은 문제부터 해결해감!!!!!! 
먼저 계산한 값을 써서 그 위 문제도 해결함!!-> 반복문 이용(iteration)

dp의 전형적인 형태는 bottom-up 방식임
결과 저쟝용 리스트(배열)는 DP 테이블이라고 부름

memoization은 이전에 계싼된 결과를 일시적으로 기록해 놓는 넓은 개념임
not just for DP
한번 계산된 결과를 담아 놓기만 하고 DP를 위해 활용하지 않을 수도 있다









'''

#top_down
d = [0] * 100 #0부터 99까지의 인덱스

def fibo(x):
    if x == 1 or x == 2:
        
        return 1
    
    if d[x] != 0:
        return d[x]
    
    d[x] = fibo(x-1) + fibo(x-2)
    
    
    return d[x]



print(fibo(99))


#bottom_up


d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[n])


'''
memoization 을 이용하면 피보나치 수열의 시간복잡도는 O(N)
'''

'''
DP 와 분할 정복은 모두 최적 부분 구조일 때 쓸 수 있다
큰 문제를 작은 문제로 나누고, 작은 문제의 답으로 큰 문제를 풀 수 있을 때

DP와 분할 정복의 차이점은 부분 문제의 중복
DP에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됨
분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않음

분할 정복 divide and conquer
의 대표적인 예인 quick sort의 경우

한번 pivot이 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않음
분할 이후에 해당 pivot을 다시 처리하는 부분 문제는 호출하지 않음


주어진 문제가 DP유형임을 파악하는 것이 중요!!

먼저 그리디, 구현, 완전 탐색으로 풀 수 있는지 생각해보고

너무 오래 걸릴 거 같으면 DP생각

재귀로 구현하고 DP로 코드를 개선할 수도 있음


점화식을 만들 수 있으면 DP활용 가능


'''












